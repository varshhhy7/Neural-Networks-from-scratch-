# -*- coding: utf-8 -*-
"""Numpy_for_NN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PYsRiZXmuldoRgVtAYl6wxNewRY8THht
"""

import numpy as np

"""# Array Creation & Basic Info

NumPy arrays (`ndarray`) are the fundamental building blocks for numerical computing in Python.  
Unlike Python lists, NumPy arrays are **homogeneous** (all elements have the same data type) and support **fast vectorized operations**.

Key concepts:  
- **Shape** → the size of the array in each dimension (e.g., `(2,3)` means 2 rows and 3 columns).  
- **ndim** → the number of dimensions (1D, 2D, 3D, etc.).  
- **dtype** → the type of elements (`int32`, `float64`, etc.).  
- **Size** → total number of elements in the array.

Arrays can be created using:  
- `np.array([...])` → from Python lists  
- `np.zeros((m,n))` → array of zeros  
- `np.ones((m,n))` → array of ones  
- `np.arange(start, stop, step)` → sequence  
- `np.linspace(start, stop, num)` → evenly spaced values  

"""

import numpy as np

x = np.array([10, 20, 30, 40])
y = np.array([[1.5, 2.5, 3.5], [4.5, 5.5, 6.5]])

print("Array x:", x)
print("Shape of x:", x.shape)
print("Array y:\n", y)
print("Dimensions of y:", y.ndim)
print("Data type of y:", y.dtype)
print("Size of y:", y.size)

"""# Array Creation & Basic Info

NumPy arrays (`ndarray`) are the fundamental building blocks for numerical computing in Python.  
Unlike Python lists, NumPy arrays are **homogeneous** (all elements have the same data type) and support **fast vectorized operations**.

Key concepts:  
- **Shape** → the size of the array in each dimension (e.g., `(2,3)` means 2 rows and 3 columns).  
- **ndim** → the number of dimensions (1D, 2D, 3D, etc.).  
- **dtype** → the type of elements (`int32`, `float64`, etc.).  
- **Size** → total number of elements in the array.

Arrays can be created using:  
- `np.array([...])` → from Python lists  
- `np.zeros((m,n))` → array of zeros  
- `np.ones((m,n))` → array of ones  
- `np.arange(start, stop, step)` → sequence  
- `np.linspace(start, stop, num)` → evenly spaced values  

"""

arr = np.array([[10,20,30],[40,50,60],[70,80,90]])

print("First row:", arr[0])
print("Second column:", arr[:,1])
print("Subarray (first 2 rows, last 2 cols):\n", arr[0:2, 1:3])
print("Last row:", arr[-1])

"""# Elementwise Operations

One of the most powerful features of NumPy is **vectorization**:  
Instead of looping through elements, operations are applied to all elements at once.

- Addition, subtraction, multiplication, division all work elementwise.  
- Exponentiation (`**`), trigonometric functions, logarithms, etc., are all vectorized.  
- **Broadcasting** allows operations between arrays of different shapes (e.g., array with scalar).

This is crucial for neural networks where we apply operations to large tensors efficiently.

"""

a = np.array([1,2,3])
b = np.array([10,20,30])

print("Addition:", a + b)        # [11 22 33]
print("Multiplication:", a * b)  # [10 40 90]
print("Squared:", a**2)          # [1 4 9]
print("Broadcasting (a*5):", a*5) # [ 5 10 15]

"""# Aggregations

Aggregations summarize data across an array:  
- `np.sum()` → total sum of elements  
- `np.mean()` → average value  
- `np.min()`, `np.max()` → minimum/maximum  
- `np.argmax()`, `np.argmin()` → index of maximum/minimum  

Axis parameter:  
- `axis=0` → operation along columns (collapse rows)  
- `axis=1` → operation along rows (collapse columns)  

In neural networks, aggregations are used for operations like **loss calculation (mean squared error)**.

"""

mat = np.array([[2,4,6],[1,3,5]])

print("Total sum:", np.sum(mat))
print("Column-wise mean:", np.mean(mat, axis=0))
print("Row-wise max:", np.max(mat, axis=1))
print("Index of min element:", np.argmin(mat))

"""# Reshape & Transpose

- **Reshape**: Changes the structure of the array without changing the data.  
  Example: a flat vector of size 6 can be reshaped into a `(2,3)` or `(3,2)` matrix.  

- **Transpose**: Swaps rows and columns (`arr.T`).  
  This is essential in linear algebra when matching matrix dimensions for multiplication.  

In neural networks, reshaping and transposing are frequently used to align weights and inputs.

"""

z = np.arange(1,7)   # [1 2 3 4 5 6]

reshaped = z.reshape(2,3)
print("Reshaped to 2x3:\n", reshaped)

transposed = reshaped.T
print("Transpose:\n", transposed)

"""# Matrix Operations

Neural networks rely heavily on **linear algebra**.  
NumPy provides efficient matrix operations:

- **Dot product** (`np.dot(a,b)`) → scalar product of two vectors.  
- **Matrix multiplication** (`@` operator or `np.matmul`) → combines two matrices.  
- **Outer product** (`np.outer`) → creates a matrix by multiplying every element of one vector by every element of another.  

These operations power forward passes in neural networks.

"""

p = np.array([1,2])
q = np.array([3,4])

M1 = np.array([[1,2],[3,4]])
M2 = np.array([[5,6],[7,8]])

print("Dot product:", np.dot(p,q))
print("Matrix multiplication:\n", M1 @ M2)
print("Outer product:\n", np.outer(p,q))

"""# Boolean Indexing & Masks

Boolean indexing allows filtering elements based on conditions:  
- `arr > value` → returns a boolean mask.  
- `arr[mask]` → returns only elements where mask is True.  
- `np.where(condition, x, y)` → replaces values based on condition.  

This is useful in neural networks for things like **applying activation functions** (e.g., ReLU sets negative values to 0).

"""

nums = np.array([3,6,9,12,15,18])

mask = nums > 10
print("Mask:", mask)
print("Elements greater than 10:", nums[mask])

print("Replace >10 with 0:", np.where(nums>10, 0, nums))

"""# Stacking & Splitting

- **Stacking** combines multiple arrays:  
  - `np.vstack` → vertical stack (row-wise)  
  - `np.hstack` → horizontal stack (column-wise)  

- **Splitting** divides an array into smaller subarrays:  
  - `np.split(arr, n)` → splits into `n` equal parts  

In practice, stacking and splitting help with **batch processing** in training.

"""

arr1 = np.array([1,2,3])
arr2 = np.array([4,5,6])

print("Vertical stack:\n", np.vstack([arr1, arr2]))
print("Horizontal stack:\n", np.hstack([arr1, arr2]))

split = np.split(np.array([10,20,30,40,50,60]), 3)
print("Splitted into 3:", split)

"""# Random Numbers

Random initialization is crucial in neural networks (weights start random to break symmetry).  

NumPy random functions:  
- `np.random.rand(m,n)` → uniform distribution [0,1).  
- `np.random.randn(m,n)` → standard normal distribution.  
- `np.random.randint(low, high, size)` → random integers.  
- `np.random.seed()` → ensures reproducibility (important in experiments).  

"""

np.random.seed(123)

rand_uniform = np.random.rand(2,3)
rand_normal = np.random.randn(2,3)
rand_int = np.random.randint(0,10,size=(2,3))

print("Random uniform:\n", rand_uniform)
print("Random normal:\n", rand_normal)
print("Random integers:\n", rand_int)

"""# Python vs NumPy Matrix Multiplication

Matrix multiplication is at the core of deep learning.  
- Neural networks repeatedly compute `weights @ inputs` (matrix-vector and matrix-matrix multiplications).  
- In **pure Python**, implementing matrix multiplication with nested loops is very slow because:
  - Each operation happens one-by-one.
  - Python lists are not optimized for numerical computation.

- In **NumPy**, operations are implemented in optimized C and Fortran under the hood (using BLAS/LAPACK).  
  This makes them **much faster** than Python loops.

In this example:  
- We generate two random matrices `A` and `B` of size `100x100`.  
- We multiply them using both:
  1. Pure Python (triple nested loops).  
  2. NumPy (`@` operator and `np.matmul`).  
- We compare the execution time.

"""

import time
import random
import numpy as np

# Size of the matrix
N = 100

# Initialize empty matrices
A = [[0]*N for _ in range(N)]
B = [[0]*N for _ in range(N)]
C = [[0]*N for _ in range(N)]

# Fill A and B with random numbers
for i in range(N):
    for j in range(N):
        A[i][j] = random.random()
        B[i][j] = random.random()

# ------------------ Pure Python Matrix Multiplication ------------------
time_start = time.time()

for i in range(N):
    for j in range(N):
        C[i][j] = 0
        for k in range(N):
            C[i][j] += A[i][k] * B[k][j]

time_end = time.time()
print("Time taken (Pure Python):", time_end - time_start)

# ------------------ NumPy Matrix Multiplication ------------------
A1 = np.random.rand(N, N)
B1 = np.random.rand(N, N)

# Method 1: Using @ operator
time_start_np = time.time()
C1 = A1 @ B1
time_end_np = time.time()
print("Time taken (NumPy @ operator):", time_end_np - time_start_np)

# Method 2: Using np.matmul
time_start_up = time.time()
C2 = np.matmul(A1, B1)
time_end_up = time.time()
print("Time taken (NumPy matmul):", time_end_up - time_start_up)

"""# 🏆 Mini Challenge – Student Scores Analysis

Imagine we have exam scores of **5 students across 3 subjects** stored in a NumPy array:
```
# ThisA = np.array([
[60, 70, 95], # Student 1
[83, 68, 79], # Student 2
[91, 39, 45], # Student 3
[90, 90, 3], # Student 4
[80, 81, 82] # Student 5
])
```

Your challenge is to use **NumPy operations** to answer the following:

1. 📊 **Find the average score of each student**  
   - Hint: Use `np.mean(..., axis=1)`  

2. 🏅 **Find the highest score in each subject**  
   - Hint: Use `np.max(..., axis=0)`  

3. 🎯 **Find the student index (roll number) who topped in each subject**  
   - Hint: Use `np.argmax(..., axis=0)`  

4. 👑 **Find the overall topper** (student with the highest total score across all subjects)  
   - Hint: First compute row-wise sum (`np.sum(..., axis=1)`), then find the index of the maximum.

---

✅ This mini challenge helps you practice:
- **Axis operations** (`axis=0` for subjects, `axis=1` for students)  
- **Aggregations** (`mean`, `max`, `sum`)  
- **Finding indices** (`argmax`)  

This is exactly how NumPy is used in real-world scenarios like processing student records, leaderboards, or performance analysis in machine learning datasets.




"""

A=np.array([[60,70,95],[83,68,79],[91,39,45],[90,90,3],[80,81,82]])

mean_scores=np.mean(A,axis=1)
print(mean_scores)

subject_top_score=np.max(A,axis=0)
print(subject_top_score)

print("Subject toppers=",np.argmax(A,axis=0))

print("overall toper is student number", np.argmax(np.sum(A , axis=1)))

